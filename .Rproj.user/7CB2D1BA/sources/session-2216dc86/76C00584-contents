#' Convert indent level to padding string of spaces
#'
#' @param indent The indenbt level as numeric.
#'
#' @return A character string
#' @keywords internal
indent_string <- function(indent = 0) {
  paste(replicate(positive_or_zero(indent), " "), collapse = "")
}

#' Issue message based on silent flag
#'
#' @param ... Message components.
#' @param silent Logical flag to suppress messages. If NULL, will check .nif_env
#'              environment (defaults to FALSE if not found).
#' @return Nothing.
#' @keywords internal
conditional_message <- function(..., silent = NULL) {
  # Get silent flag from parameter or environment
  if (is.null(silent)) {
    silent <- tryCatch({
      get("silent", envir = .nif_env)
    }, error = function(e) {
      FALSE
    })
  }

  # Safely convert arguments to character
  args <- tryCatch({
    lapply(list(...), as.character)
  }, error = function(e) {
    warning("Failed to convert some arguments to character")
    list(...)
  })

  # Print message if not silent
  if (!isTRUE(silent)) {
    message(paste(args, collapse = ""))
  }

  invisible(NULL)
}


#' Render data frame object to string
#'
#' This function renders a data.frame into a string similar to its
#' representation when printed without line numbers
#'
#' @param df The data.frame to be rendered.
#' @param indent Indentation level, as numeric.
#' @param header Boolean to indicate whether the header row is to be included.
#' @param color Print headers in grey as logical.
#' @param n The number of lines to be included, or all if NULL.
#' @param show_none Show empty data frame as 'none', as logical.
#' @param header_sep Show separation line after header, as logical.
#' @param na_string String to use for NA values. Defaults to "NA".
#'
#' @return The output as string.
#' @import utils
#' @keywords internal
df_to_string <- function(
    df,
    indent = 0,
    n = NULL,
    header = TRUE,
    header_sep = FALSE,
    color = FALSE,
    show_none = FALSE,
    na_string = "NA"
) {

  # Input validation
  if(is.null(df))
    return("")

  # if (!is.data.frame(df) & !is_tibble(df)) {
  if(!inherits(df, "data.frame")){
    stop("Input must be a data frame")
  }


  if (!is.numeric(indent) || indent < 0) {
    stop("Indent must be a non-negative number")
  }

  # Handle empty data frame early
  if (nrow(df) == 0) {
    if (show_none) {
      return(paste0(indent_string(indent), "none\n"))
    }
    return("")
  }

  # Convert all columns to character, handling NA values
  df <- as.data.frame(df) %>%
    mutate(across(everything(), ~ifelse(is.na(.), na_string, as.character(.))))

  # Calculate maximum width for each column including headers
  max_widths <- sapply(
    seq_along(df),
    function(i) max(
      nchar(names(df)[i]),
      max(nchar(as.character(df[[i]])), na.rm = TRUE)
    )
  )

  # Create the padding function
  pad_element <- function(element, width) {
    sprintf(paste0("%-", width, "s   "), element)
  }

  # Create line renderer
  render_line <- function(line) {
    paste0(
      indent_string(indent),
      paste0(
        mapply(
          pad_element,
          element = as.character(line),
          width = max_widths
        ),
        collapse = ""
      )
    )
  }

  # Build output starting with header if requested
  output_parts <- character(0)

  if (header) {
    header_line <- render_line(names(df))
    if (color) {
      header_line <- paste0("\u001b[38;5;248m", header_line, "\u001b[0m")
    }
    output_parts <- c(output_parts, header_line)

    if (header_sep) {
      separator <- paste0(
        indent_string(indent),
        paste(mapply(function(w) paste(rep("-", w), collapse = ""),
                     max_widths),
              collapse = "   ")
      )
      output_parts <- c(output_parts, separator)
    }
  }

  # Add data rows
  data_rows <- if (!is.null(n)) utils::head(df, n = n) else df
  row_strings <- apply(data_rows, 1, render_line)
  output_parts <- c(output_parts, row_strings)

  # Combine all parts with newlines
  paste(output_parts, collapse = "\n")
}

#' Nice enumeration of multiple strings
#'
#' @param items Items to enumerate as character.
#' @param conjunction The conjunction between the last and penultmate items.
#'
#' @return Enumeration as character.
#' @export
#' @keywords internal
#'
#' @examples
#' nice_enumeration("A")
#' nice_enumeration(c("A", "B"))
#' nice_enumeration(c("A", "B", "C"))
#' nice_enumeration(c("A", "B", "C"), conjunction = "or")
nice_enumeration <- function(items, conjunction = "and") {
  if (length(items) == 1) {
    return(items[[1]])
  }
  if (length(items) > 1) {
    return(paste(
      paste(items[1:length(items) - 1], collapse = ", "), conjunction,
      items[length(items)]
    ))
  }
}

#' Return singular or plural form of word
#'
#' @param word Source word in singular form, as character.
#' @param plural Return plural form, as character.
#'
#' @return Character.
#' @export
#' @keywords internal
#' @examples
#' plural("subject", FALSE)
#' plural("subject", TRUE)
#' plural("study", FALSE)
#' plural("study", TRUE)
plural <- function(word, plural) {
  exceptions = tribble(
    ~singular, ~plural,
    "study", "studies",
    "Study", "Studies"
  )
  if(plural) {
    if(word %in% exceptions$singular)
      return(as.character(exceptions[exceptions$singular == word, "plural"]))
    else
      return(paste0(word, "s"))
  } else {
    return(word)
  }
}

